
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Roster` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Roster
 * 
 */
export type RosterModel = runtime.Types.Result.DefaultSelection<Prisma.$RosterPayload>

export type AggregateRoster = {
  _count: RosterCountAggregateOutputType | null
  _avg: RosterAvgAggregateOutputType | null
  _sum: RosterSumAggregateOutputType | null
  _min: RosterMinAggregateOutputType | null
  _max: RosterMaxAggregateOutputType | null
}

export type RosterAvgAggregateOutputType = {
  week: number | null
  season: number | null
}

export type RosterSumAggregateOutputType = {
  week: number | null
  season: number | null
}

export type RosterMinAggregateOutputType = {
  id: string | null
  createdAt: Date | null
  updatedAt: Date | null
  leagueId: string | null
  memberId: string | null
  week: number | null
  season: number | null
}

export type RosterMaxAggregateOutputType = {
  id: string | null
  createdAt: Date | null
  updatedAt: Date | null
  leagueId: string | null
  memberId: string | null
  week: number | null
  season: number | null
}

export type RosterCountAggregateOutputType = {
  id: number
  createdAt: number
  updatedAt: number
  leagueId: number
  memberId: number
  week: number
  season: number
  _all: number
}


export type RosterAvgAggregateInputType = {
  week?: true
  season?: true
}

export type RosterSumAggregateInputType = {
  week?: true
  season?: true
}

export type RosterMinAggregateInputType = {
  id?: true
  createdAt?: true
  updatedAt?: true
  leagueId?: true
  memberId?: true
  week?: true
  season?: true
}

export type RosterMaxAggregateInputType = {
  id?: true
  createdAt?: true
  updatedAt?: true
  leagueId?: true
  memberId?: true
  week?: true
  season?: true
}

export type RosterCountAggregateInputType = {
  id?: true
  createdAt?: true
  updatedAt?: true
  leagueId?: true
  memberId?: true
  week?: true
  season?: true
  _all?: true
}

export type RosterAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Roster to aggregate.
   */
  where?: Prisma.RosterWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Rosters to fetch.
   */
  orderBy?: Prisma.RosterOrderByWithRelationInput | Prisma.RosterOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.RosterWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Rosters from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Rosters.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Rosters
  **/
  _count?: true | RosterCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: RosterAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: RosterSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: RosterMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: RosterMaxAggregateInputType
}

export type GetRosterAggregateType<T extends RosterAggregateArgs> = {
      [P in keyof T & keyof AggregateRoster]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateRoster[P]>
    : Prisma.GetScalarType<T[P], AggregateRoster[P]>
}




export type RosterGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.RosterWhereInput
  orderBy?: Prisma.RosterOrderByWithAggregationInput | Prisma.RosterOrderByWithAggregationInput[]
  by: Prisma.RosterScalarFieldEnum[] | Prisma.RosterScalarFieldEnum
  having?: Prisma.RosterScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: RosterCountAggregateInputType | true
  _avg?: RosterAvgAggregateInputType
  _sum?: RosterSumAggregateInputType
  _min?: RosterMinAggregateInputType
  _max?: RosterMaxAggregateInputType
}

export type RosterGroupByOutputType = {
  id: string
  createdAt: Date
  updatedAt: Date
  leagueId: string
  memberId: string
  week: number
  season: number
  _count: RosterCountAggregateOutputType | null
  _avg: RosterAvgAggregateOutputType | null
  _sum: RosterSumAggregateOutputType | null
  _min: RosterMinAggregateOutputType | null
  _max: RosterMaxAggregateOutputType | null
}

type GetRosterGroupByPayload<T extends RosterGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<RosterGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof RosterGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], RosterGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], RosterGroupByOutputType[P]>
      }
    >
  >



export type RosterWhereInput = {
  AND?: Prisma.RosterWhereInput | Prisma.RosterWhereInput[]
  OR?: Prisma.RosterWhereInput[]
  NOT?: Prisma.RosterWhereInput | Prisma.RosterWhereInput[]
  id?: Prisma.StringFilter<"Roster"> | string
  createdAt?: Prisma.DateTimeFilter<"Roster"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Roster"> | Date | string
  leagueId?: Prisma.StringFilter<"Roster"> | string
  memberId?: Prisma.StringFilter<"Roster"> | string
  week?: Prisma.IntFilter<"Roster"> | number
  season?: Prisma.IntFilter<"Roster"> | number
  league?: Prisma.XOR<Prisma.LeagueScalarRelationFilter, Prisma.LeagueWhereInput>
  member?: Prisma.XOR<Prisma.LeagueMemberScalarRelationFilter, Prisma.LeagueMemberWhereInput>
  players?: Prisma.RosterPlayerListRelationFilter
}

export type RosterOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  leagueId?: Prisma.SortOrder
  memberId?: Prisma.SortOrder
  week?: Prisma.SortOrder
  season?: Prisma.SortOrder
  league?: Prisma.LeagueOrderByWithRelationInput
  member?: Prisma.LeagueMemberOrderByWithRelationInput
  players?: Prisma.RosterPlayerOrderByRelationAggregateInput
}

export type RosterWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  memberId_week_season?: Prisma.RosterMemberIdWeekSeasonCompoundUniqueInput
  AND?: Prisma.RosterWhereInput | Prisma.RosterWhereInput[]
  OR?: Prisma.RosterWhereInput[]
  NOT?: Prisma.RosterWhereInput | Prisma.RosterWhereInput[]
  createdAt?: Prisma.DateTimeFilter<"Roster"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Roster"> | Date | string
  leagueId?: Prisma.StringFilter<"Roster"> | string
  memberId?: Prisma.StringFilter<"Roster"> | string
  week?: Prisma.IntFilter<"Roster"> | number
  season?: Prisma.IntFilter<"Roster"> | number
  league?: Prisma.XOR<Prisma.LeagueScalarRelationFilter, Prisma.LeagueWhereInput>
  member?: Prisma.XOR<Prisma.LeagueMemberScalarRelationFilter, Prisma.LeagueMemberWhereInput>
  players?: Prisma.RosterPlayerListRelationFilter
}, "id" | "memberId_week_season">

export type RosterOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  leagueId?: Prisma.SortOrder
  memberId?: Prisma.SortOrder
  week?: Prisma.SortOrder
  season?: Prisma.SortOrder
  _count?: Prisma.RosterCountOrderByAggregateInput
  _avg?: Prisma.RosterAvgOrderByAggregateInput
  _max?: Prisma.RosterMaxOrderByAggregateInput
  _min?: Prisma.RosterMinOrderByAggregateInput
  _sum?: Prisma.RosterSumOrderByAggregateInput
}

export type RosterScalarWhereWithAggregatesInput = {
  AND?: Prisma.RosterScalarWhereWithAggregatesInput | Prisma.RosterScalarWhereWithAggregatesInput[]
  OR?: Prisma.RosterScalarWhereWithAggregatesInput[]
  NOT?: Prisma.RosterScalarWhereWithAggregatesInput | Prisma.RosterScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"Roster"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Roster"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"Roster"> | Date | string
  leagueId?: Prisma.StringWithAggregatesFilter<"Roster"> | string
  memberId?: Prisma.StringWithAggregatesFilter<"Roster"> | string
  week?: Prisma.IntWithAggregatesFilter<"Roster"> | number
  season?: Prisma.IntWithAggregatesFilter<"Roster"> | number
}

export type RosterCreateInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  week: number
  season: number
  league: Prisma.LeagueCreateNestedOneWithoutRostersInput
  member: Prisma.LeagueMemberCreateNestedOneWithoutRostersInput
  players?: Prisma.RosterPlayerCreateNestedManyWithoutRosterInput
}

export type RosterUncheckedCreateInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  leagueId: string
  memberId: string
  week: number
  season: number
  players?: Prisma.RosterPlayerUncheckedCreateNestedManyWithoutRosterInput
}

export type RosterUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  week?: Prisma.IntFieldUpdateOperationsInput | number
  season?: Prisma.IntFieldUpdateOperationsInput | number
  league?: Prisma.LeagueUpdateOneRequiredWithoutRostersNestedInput
  member?: Prisma.LeagueMemberUpdateOneRequiredWithoutRostersNestedInput
  players?: Prisma.RosterPlayerUpdateManyWithoutRosterNestedInput
}

export type RosterUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  leagueId?: Prisma.StringFieldUpdateOperationsInput | string
  memberId?: Prisma.StringFieldUpdateOperationsInput | string
  week?: Prisma.IntFieldUpdateOperationsInput | number
  season?: Prisma.IntFieldUpdateOperationsInput | number
  players?: Prisma.RosterPlayerUncheckedUpdateManyWithoutRosterNestedInput
}

export type RosterCreateManyInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  leagueId: string
  memberId: string
  week: number
  season: number
}

export type RosterUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  week?: Prisma.IntFieldUpdateOperationsInput | number
  season?: Prisma.IntFieldUpdateOperationsInput | number
}

export type RosterUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  leagueId?: Prisma.StringFieldUpdateOperationsInput | string
  memberId?: Prisma.StringFieldUpdateOperationsInput | string
  week?: Prisma.IntFieldUpdateOperationsInput | number
  season?: Prisma.IntFieldUpdateOperationsInput | number
}

export type RosterListRelationFilter = {
  every?: Prisma.RosterWhereInput
  some?: Prisma.RosterWhereInput
  none?: Prisma.RosterWhereInput
}

export type RosterOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type RosterMemberIdWeekSeasonCompoundUniqueInput = {
  memberId: string
  week: number
  season: number
}

export type RosterCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  leagueId?: Prisma.SortOrder
  memberId?: Prisma.SortOrder
  week?: Prisma.SortOrder
  season?: Prisma.SortOrder
}

export type RosterAvgOrderByAggregateInput = {
  week?: Prisma.SortOrder
  season?: Prisma.SortOrder
}

export type RosterMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  leagueId?: Prisma.SortOrder
  memberId?: Prisma.SortOrder
  week?: Prisma.SortOrder
  season?: Prisma.SortOrder
}

export type RosterMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  leagueId?: Prisma.SortOrder
  memberId?: Prisma.SortOrder
  week?: Prisma.SortOrder
  season?: Prisma.SortOrder
}

export type RosterSumOrderByAggregateInput = {
  week?: Prisma.SortOrder
  season?: Prisma.SortOrder
}

export type RosterScalarRelationFilter = {
  is?: Prisma.RosterWhereInput
  isNot?: Prisma.RosterWhereInput
}

export type RosterCreateNestedManyWithoutLeagueInput = {
  create?: Prisma.XOR<Prisma.RosterCreateWithoutLeagueInput, Prisma.RosterUncheckedCreateWithoutLeagueInput> | Prisma.RosterCreateWithoutLeagueInput[] | Prisma.RosterUncheckedCreateWithoutLeagueInput[]
  connectOrCreate?: Prisma.RosterCreateOrConnectWithoutLeagueInput | Prisma.RosterCreateOrConnectWithoutLeagueInput[]
  createMany?: Prisma.RosterCreateManyLeagueInputEnvelope
  connect?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
}

export type RosterUncheckedCreateNestedManyWithoutLeagueInput = {
  create?: Prisma.XOR<Prisma.RosterCreateWithoutLeagueInput, Prisma.RosterUncheckedCreateWithoutLeagueInput> | Prisma.RosterCreateWithoutLeagueInput[] | Prisma.RosterUncheckedCreateWithoutLeagueInput[]
  connectOrCreate?: Prisma.RosterCreateOrConnectWithoutLeagueInput | Prisma.RosterCreateOrConnectWithoutLeagueInput[]
  createMany?: Prisma.RosterCreateManyLeagueInputEnvelope
  connect?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
}

export type RosterUpdateManyWithoutLeagueNestedInput = {
  create?: Prisma.XOR<Prisma.RosterCreateWithoutLeagueInput, Prisma.RosterUncheckedCreateWithoutLeagueInput> | Prisma.RosterCreateWithoutLeagueInput[] | Prisma.RosterUncheckedCreateWithoutLeagueInput[]
  connectOrCreate?: Prisma.RosterCreateOrConnectWithoutLeagueInput | Prisma.RosterCreateOrConnectWithoutLeagueInput[]
  upsert?: Prisma.RosterUpsertWithWhereUniqueWithoutLeagueInput | Prisma.RosterUpsertWithWhereUniqueWithoutLeagueInput[]
  createMany?: Prisma.RosterCreateManyLeagueInputEnvelope
  set?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  disconnect?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  delete?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  connect?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  update?: Prisma.RosterUpdateWithWhereUniqueWithoutLeagueInput | Prisma.RosterUpdateWithWhereUniqueWithoutLeagueInput[]
  updateMany?: Prisma.RosterUpdateManyWithWhereWithoutLeagueInput | Prisma.RosterUpdateManyWithWhereWithoutLeagueInput[]
  deleteMany?: Prisma.RosterScalarWhereInput | Prisma.RosterScalarWhereInput[]
}

export type RosterUncheckedUpdateManyWithoutLeagueNestedInput = {
  create?: Prisma.XOR<Prisma.RosterCreateWithoutLeagueInput, Prisma.RosterUncheckedCreateWithoutLeagueInput> | Prisma.RosterCreateWithoutLeagueInput[] | Prisma.RosterUncheckedCreateWithoutLeagueInput[]
  connectOrCreate?: Prisma.RosterCreateOrConnectWithoutLeagueInput | Prisma.RosterCreateOrConnectWithoutLeagueInput[]
  upsert?: Prisma.RosterUpsertWithWhereUniqueWithoutLeagueInput | Prisma.RosterUpsertWithWhereUniqueWithoutLeagueInput[]
  createMany?: Prisma.RosterCreateManyLeagueInputEnvelope
  set?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  disconnect?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  delete?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  connect?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  update?: Prisma.RosterUpdateWithWhereUniqueWithoutLeagueInput | Prisma.RosterUpdateWithWhereUniqueWithoutLeagueInput[]
  updateMany?: Prisma.RosterUpdateManyWithWhereWithoutLeagueInput | Prisma.RosterUpdateManyWithWhereWithoutLeagueInput[]
  deleteMany?: Prisma.RosterScalarWhereInput | Prisma.RosterScalarWhereInput[]
}

export type RosterCreateNestedManyWithoutMemberInput = {
  create?: Prisma.XOR<Prisma.RosterCreateWithoutMemberInput, Prisma.RosterUncheckedCreateWithoutMemberInput> | Prisma.RosterCreateWithoutMemberInput[] | Prisma.RosterUncheckedCreateWithoutMemberInput[]
  connectOrCreate?: Prisma.RosterCreateOrConnectWithoutMemberInput | Prisma.RosterCreateOrConnectWithoutMemberInput[]
  createMany?: Prisma.RosterCreateManyMemberInputEnvelope
  connect?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
}

export type RosterUncheckedCreateNestedManyWithoutMemberInput = {
  create?: Prisma.XOR<Prisma.RosterCreateWithoutMemberInput, Prisma.RosterUncheckedCreateWithoutMemberInput> | Prisma.RosterCreateWithoutMemberInput[] | Prisma.RosterUncheckedCreateWithoutMemberInput[]
  connectOrCreate?: Prisma.RosterCreateOrConnectWithoutMemberInput | Prisma.RosterCreateOrConnectWithoutMemberInput[]
  createMany?: Prisma.RosterCreateManyMemberInputEnvelope
  connect?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
}

export type RosterUpdateManyWithoutMemberNestedInput = {
  create?: Prisma.XOR<Prisma.RosterCreateWithoutMemberInput, Prisma.RosterUncheckedCreateWithoutMemberInput> | Prisma.RosterCreateWithoutMemberInput[] | Prisma.RosterUncheckedCreateWithoutMemberInput[]
  connectOrCreate?: Prisma.RosterCreateOrConnectWithoutMemberInput | Prisma.RosterCreateOrConnectWithoutMemberInput[]
  upsert?: Prisma.RosterUpsertWithWhereUniqueWithoutMemberInput | Prisma.RosterUpsertWithWhereUniqueWithoutMemberInput[]
  createMany?: Prisma.RosterCreateManyMemberInputEnvelope
  set?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  disconnect?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  delete?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  connect?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  update?: Prisma.RosterUpdateWithWhereUniqueWithoutMemberInput | Prisma.RosterUpdateWithWhereUniqueWithoutMemberInput[]
  updateMany?: Prisma.RosterUpdateManyWithWhereWithoutMemberInput | Prisma.RosterUpdateManyWithWhereWithoutMemberInput[]
  deleteMany?: Prisma.RosterScalarWhereInput | Prisma.RosterScalarWhereInput[]
}

export type RosterUncheckedUpdateManyWithoutMemberNestedInput = {
  create?: Prisma.XOR<Prisma.RosterCreateWithoutMemberInput, Prisma.RosterUncheckedCreateWithoutMemberInput> | Prisma.RosterCreateWithoutMemberInput[] | Prisma.RosterUncheckedCreateWithoutMemberInput[]
  connectOrCreate?: Prisma.RosterCreateOrConnectWithoutMemberInput | Prisma.RosterCreateOrConnectWithoutMemberInput[]
  upsert?: Prisma.RosterUpsertWithWhereUniqueWithoutMemberInput | Prisma.RosterUpsertWithWhereUniqueWithoutMemberInput[]
  createMany?: Prisma.RosterCreateManyMemberInputEnvelope
  set?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  disconnect?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  delete?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  connect?: Prisma.RosterWhereUniqueInput | Prisma.RosterWhereUniqueInput[]
  update?: Prisma.RosterUpdateWithWhereUniqueWithoutMemberInput | Prisma.RosterUpdateWithWhereUniqueWithoutMemberInput[]
  updateMany?: Prisma.RosterUpdateManyWithWhereWithoutMemberInput | Prisma.RosterUpdateManyWithWhereWithoutMemberInput[]
  deleteMany?: Prisma.RosterScalarWhereInput | Prisma.RosterScalarWhereInput[]
}

export type RosterCreateNestedOneWithoutPlayersInput = {
  create?: Prisma.XOR<Prisma.RosterCreateWithoutPlayersInput, Prisma.RosterUncheckedCreateWithoutPlayersInput>
  connectOrCreate?: Prisma.RosterCreateOrConnectWithoutPlayersInput
  connect?: Prisma.RosterWhereUniqueInput
}

export type RosterUpdateOneRequiredWithoutPlayersNestedInput = {
  create?: Prisma.XOR<Prisma.RosterCreateWithoutPlayersInput, Prisma.RosterUncheckedCreateWithoutPlayersInput>
  connectOrCreate?: Prisma.RosterCreateOrConnectWithoutPlayersInput
  upsert?: Prisma.RosterUpsertWithoutPlayersInput
  connect?: Prisma.RosterWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.RosterUpdateToOneWithWhereWithoutPlayersInput, Prisma.RosterUpdateWithoutPlayersInput>, Prisma.RosterUncheckedUpdateWithoutPlayersInput>
}

export type RosterCreateWithoutLeagueInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  week: number
  season: number
  member: Prisma.LeagueMemberCreateNestedOneWithoutRostersInput
  players?: Prisma.RosterPlayerCreateNestedManyWithoutRosterInput
}

export type RosterUncheckedCreateWithoutLeagueInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  memberId: string
  week: number
  season: number
  players?: Prisma.RosterPlayerUncheckedCreateNestedManyWithoutRosterInput
}

export type RosterCreateOrConnectWithoutLeagueInput = {
  where: Prisma.RosterWhereUniqueInput
  create: Prisma.XOR<Prisma.RosterCreateWithoutLeagueInput, Prisma.RosterUncheckedCreateWithoutLeagueInput>
}

export type RosterCreateManyLeagueInputEnvelope = {
  data: Prisma.RosterCreateManyLeagueInput | Prisma.RosterCreateManyLeagueInput[]
  skipDuplicates?: boolean
}

export type RosterUpsertWithWhereUniqueWithoutLeagueInput = {
  where: Prisma.RosterWhereUniqueInput
  update: Prisma.XOR<Prisma.RosterUpdateWithoutLeagueInput, Prisma.RosterUncheckedUpdateWithoutLeagueInput>
  create: Prisma.XOR<Prisma.RosterCreateWithoutLeagueInput, Prisma.RosterUncheckedCreateWithoutLeagueInput>
}

export type RosterUpdateWithWhereUniqueWithoutLeagueInput = {
  where: Prisma.RosterWhereUniqueInput
  data: Prisma.XOR<Prisma.RosterUpdateWithoutLeagueInput, Prisma.RosterUncheckedUpdateWithoutLeagueInput>
}

export type RosterUpdateManyWithWhereWithoutLeagueInput = {
  where: Prisma.RosterScalarWhereInput
  data: Prisma.XOR<Prisma.RosterUpdateManyMutationInput, Prisma.RosterUncheckedUpdateManyWithoutLeagueInput>
}

export type RosterScalarWhereInput = {
  AND?: Prisma.RosterScalarWhereInput | Prisma.RosterScalarWhereInput[]
  OR?: Prisma.RosterScalarWhereInput[]
  NOT?: Prisma.RosterScalarWhereInput | Prisma.RosterScalarWhereInput[]
  id?: Prisma.StringFilter<"Roster"> | string
  createdAt?: Prisma.DateTimeFilter<"Roster"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Roster"> | Date | string
  leagueId?: Prisma.StringFilter<"Roster"> | string
  memberId?: Prisma.StringFilter<"Roster"> | string
  week?: Prisma.IntFilter<"Roster"> | number
  season?: Prisma.IntFilter<"Roster"> | number
}

export type RosterCreateWithoutMemberInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  week: number
  season: number
  league: Prisma.LeagueCreateNestedOneWithoutRostersInput
  players?: Prisma.RosterPlayerCreateNestedManyWithoutRosterInput
}

export type RosterUncheckedCreateWithoutMemberInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  leagueId: string
  week: number
  season: number
  players?: Prisma.RosterPlayerUncheckedCreateNestedManyWithoutRosterInput
}

export type RosterCreateOrConnectWithoutMemberInput = {
  where: Prisma.RosterWhereUniqueInput
  create: Prisma.XOR<Prisma.RosterCreateWithoutMemberInput, Prisma.RosterUncheckedCreateWithoutMemberInput>
}

export type RosterCreateManyMemberInputEnvelope = {
  data: Prisma.RosterCreateManyMemberInput | Prisma.RosterCreateManyMemberInput[]
  skipDuplicates?: boolean
}

export type RosterUpsertWithWhereUniqueWithoutMemberInput = {
  where: Prisma.RosterWhereUniqueInput
  update: Prisma.XOR<Prisma.RosterUpdateWithoutMemberInput, Prisma.RosterUncheckedUpdateWithoutMemberInput>
  create: Prisma.XOR<Prisma.RosterCreateWithoutMemberInput, Prisma.RosterUncheckedCreateWithoutMemberInput>
}

export type RosterUpdateWithWhereUniqueWithoutMemberInput = {
  where: Prisma.RosterWhereUniqueInput
  data: Prisma.XOR<Prisma.RosterUpdateWithoutMemberInput, Prisma.RosterUncheckedUpdateWithoutMemberInput>
}

export type RosterUpdateManyWithWhereWithoutMemberInput = {
  where: Prisma.RosterScalarWhereInput
  data: Prisma.XOR<Prisma.RosterUpdateManyMutationInput, Prisma.RosterUncheckedUpdateManyWithoutMemberInput>
}

export type RosterCreateWithoutPlayersInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  week: number
  season: number
  league: Prisma.LeagueCreateNestedOneWithoutRostersInput
  member: Prisma.LeagueMemberCreateNestedOneWithoutRostersInput
}

export type RosterUncheckedCreateWithoutPlayersInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  leagueId: string
  memberId: string
  week: number
  season: number
}

export type RosterCreateOrConnectWithoutPlayersInput = {
  where: Prisma.RosterWhereUniqueInput
  create: Prisma.XOR<Prisma.RosterCreateWithoutPlayersInput, Prisma.RosterUncheckedCreateWithoutPlayersInput>
}

export type RosterUpsertWithoutPlayersInput = {
  update: Prisma.XOR<Prisma.RosterUpdateWithoutPlayersInput, Prisma.RosterUncheckedUpdateWithoutPlayersInput>
  create: Prisma.XOR<Prisma.RosterCreateWithoutPlayersInput, Prisma.RosterUncheckedCreateWithoutPlayersInput>
  where?: Prisma.RosterWhereInput
}

export type RosterUpdateToOneWithWhereWithoutPlayersInput = {
  where?: Prisma.RosterWhereInput
  data: Prisma.XOR<Prisma.RosterUpdateWithoutPlayersInput, Prisma.RosterUncheckedUpdateWithoutPlayersInput>
}

export type RosterUpdateWithoutPlayersInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  week?: Prisma.IntFieldUpdateOperationsInput | number
  season?: Prisma.IntFieldUpdateOperationsInput | number
  league?: Prisma.LeagueUpdateOneRequiredWithoutRostersNestedInput
  member?: Prisma.LeagueMemberUpdateOneRequiredWithoutRostersNestedInput
}

export type RosterUncheckedUpdateWithoutPlayersInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  leagueId?: Prisma.StringFieldUpdateOperationsInput | string
  memberId?: Prisma.StringFieldUpdateOperationsInput | string
  week?: Prisma.IntFieldUpdateOperationsInput | number
  season?: Prisma.IntFieldUpdateOperationsInput | number
}

export type RosterCreateManyLeagueInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  memberId: string
  week: number
  season: number
}

export type RosterUpdateWithoutLeagueInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  week?: Prisma.IntFieldUpdateOperationsInput | number
  season?: Prisma.IntFieldUpdateOperationsInput | number
  member?: Prisma.LeagueMemberUpdateOneRequiredWithoutRostersNestedInput
  players?: Prisma.RosterPlayerUpdateManyWithoutRosterNestedInput
}

export type RosterUncheckedUpdateWithoutLeagueInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  memberId?: Prisma.StringFieldUpdateOperationsInput | string
  week?: Prisma.IntFieldUpdateOperationsInput | number
  season?: Prisma.IntFieldUpdateOperationsInput | number
  players?: Prisma.RosterPlayerUncheckedUpdateManyWithoutRosterNestedInput
}

export type RosterUncheckedUpdateManyWithoutLeagueInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  memberId?: Prisma.StringFieldUpdateOperationsInput | string
  week?: Prisma.IntFieldUpdateOperationsInput | number
  season?: Prisma.IntFieldUpdateOperationsInput | number
}

export type RosterCreateManyMemberInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  leagueId: string
  week: number
  season: number
}

export type RosterUpdateWithoutMemberInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  week?: Prisma.IntFieldUpdateOperationsInput | number
  season?: Prisma.IntFieldUpdateOperationsInput | number
  league?: Prisma.LeagueUpdateOneRequiredWithoutRostersNestedInput
  players?: Prisma.RosterPlayerUpdateManyWithoutRosterNestedInput
}

export type RosterUncheckedUpdateWithoutMemberInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  leagueId?: Prisma.StringFieldUpdateOperationsInput | string
  week?: Prisma.IntFieldUpdateOperationsInput | number
  season?: Prisma.IntFieldUpdateOperationsInput | number
  players?: Prisma.RosterPlayerUncheckedUpdateManyWithoutRosterNestedInput
}

export type RosterUncheckedUpdateManyWithoutMemberInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  leagueId?: Prisma.StringFieldUpdateOperationsInput | string
  week?: Prisma.IntFieldUpdateOperationsInput | number
  season?: Prisma.IntFieldUpdateOperationsInput | number
}


/**
 * Count Type RosterCountOutputType
 */

export type RosterCountOutputType = {
  players: number
}

export type RosterCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  players?: boolean | RosterCountOutputTypeCountPlayersArgs
}

/**
 * RosterCountOutputType without action
 */
export type RosterCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RosterCountOutputType
   */
  select?: Prisma.RosterCountOutputTypeSelect<ExtArgs> | null
}

/**
 * RosterCountOutputType without action
 */
export type RosterCountOutputTypeCountPlayersArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.RosterPlayerWhereInput
}


export type RosterSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  leagueId?: boolean
  memberId?: boolean
  week?: boolean
  season?: boolean
  league?: boolean | Prisma.LeagueDefaultArgs<ExtArgs>
  member?: boolean | Prisma.LeagueMemberDefaultArgs<ExtArgs>
  players?: boolean | Prisma.Roster$playersArgs<ExtArgs>
  _count?: boolean | Prisma.RosterCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["roster"]>

export type RosterSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  leagueId?: boolean
  memberId?: boolean
  week?: boolean
  season?: boolean
  league?: boolean | Prisma.LeagueDefaultArgs<ExtArgs>
  member?: boolean | Prisma.LeagueMemberDefaultArgs<ExtArgs>
}, ExtArgs["result"]["roster"]>

export type RosterSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  leagueId?: boolean
  memberId?: boolean
  week?: boolean
  season?: boolean
  league?: boolean | Prisma.LeagueDefaultArgs<ExtArgs>
  member?: boolean | Prisma.LeagueMemberDefaultArgs<ExtArgs>
}, ExtArgs["result"]["roster"]>

export type RosterSelectScalar = {
  id?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  leagueId?: boolean
  memberId?: boolean
  week?: boolean
  season?: boolean
}

export type RosterOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "leagueId" | "memberId" | "week" | "season", ExtArgs["result"]["roster"]>
export type RosterInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  league?: boolean | Prisma.LeagueDefaultArgs<ExtArgs>
  member?: boolean | Prisma.LeagueMemberDefaultArgs<ExtArgs>
  players?: boolean | Prisma.Roster$playersArgs<ExtArgs>
  _count?: boolean | Prisma.RosterCountOutputTypeDefaultArgs<ExtArgs>
}
export type RosterIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  league?: boolean | Prisma.LeagueDefaultArgs<ExtArgs>
  member?: boolean | Prisma.LeagueMemberDefaultArgs<ExtArgs>
}
export type RosterIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  league?: boolean | Prisma.LeagueDefaultArgs<ExtArgs>
  member?: boolean | Prisma.LeagueMemberDefaultArgs<ExtArgs>
}

export type $RosterPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Roster"
  objects: {
    league: Prisma.$LeaguePayload<ExtArgs>
    member: Prisma.$LeagueMemberPayload<ExtArgs>
    players: Prisma.$RosterPlayerPayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    createdAt: Date
    updatedAt: Date
    leagueId: string
    memberId: string
    week: number
    season: number
  }, ExtArgs["result"]["roster"]>
  composites: {}
}

export type RosterGetPayload<S extends boolean | null | undefined | RosterDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$RosterPayload, S>

export type RosterCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<RosterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: RosterCountAggregateInputType | true
  }

export interface RosterDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roster'], meta: { name: 'Roster' } }
  /**
   * Find zero or one Roster that matches the filter.
   * @param {RosterFindUniqueArgs} args - Arguments to find a Roster
   * @example
   * // Get one Roster
   * const roster = await prisma.roster.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends RosterFindUniqueArgs>(args: Prisma.SelectSubset<T, RosterFindUniqueArgs<ExtArgs>>): Prisma.Prisma__RosterClient<runtime.Types.Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Roster that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {RosterFindUniqueOrThrowArgs} args - Arguments to find a Roster
   * @example
   * // Get one Roster
   * const roster = await prisma.roster.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends RosterFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, RosterFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__RosterClient<runtime.Types.Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Roster that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RosterFindFirstArgs} args - Arguments to find a Roster
   * @example
   * // Get one Roster
   * const roster = await prisma.roster.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends RosterFindFirstArgs>(args?: Prisma.SelectSubset<T, RosterFindFirstArgs<ExtArgs>>): Prisma.Prisma__RosterClient<runtime.Types.Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Roster that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RosterFindFirstOrThrowArgs} args - Arguments to find a Roster
   * @example
   * // Get one Roster
   * const roster = await prisma.roster.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends RosterFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, RosterFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__RosterClient<runtime.Types.Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Rosters that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RosterFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Rosters
   * const rosters = await prisma.roster.findMany()
   * 
   * // Get first 10 Rosters
   * const rosters = await prisma.roster.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const rosterWithIdOnly = await prisma.roster.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends RosterFindManyArgs>(args?: Prisma.SelectSubset<T, RosterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Roster.
   * @param {RosterCreateArgs} args - Arguments to create a Roster.
   * @example
   * // Create one Roster
   * const Roster = await prisma.roster.create({
   *   data: {
   *     // ... data to create a Roster
   *   }
   * })
   * 
   */
  create<T extends RosterCreateArgs>(args: Prisma.SelectSubset<T, RosterCreateArgs<ExtArgs>>): Prisma.Prisma__RosterClient<runtime.Types.Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Rosters.
   * @param {RosterCreateManyArgs} args - Arguments to create many Rosters.
   * @example
   * // Create many Rosters
   * const roster = await prisma.roster.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends RosterCreateManyArgs>(args?: Prisma.SelectSubset<T, RosterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Rosters and returns the data saved in the database.
   * @param {RosterCreateManyAndReturnArgs} args - Arguments to create many Rosters.
   * @example
   * // Create many Rosters
   * const roster = await prisma.roster.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Rosters and only return the `id`
   * const rosterWithIdOnly = await prisma.roster.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends RosterCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, RosterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Roster.
   * @param {RosterDeleteArgs} args - Arguments to delete one Roster.
   * @example
   * // Delete one Roster
   * const Roster = await prisma.roster.delete({
   *   where: {
   *     // ... filter to delete one Roster
   *   }
   * })
   * 
   */
  delete<T extends RosterDeleteArgs>(args: Prisma.SelectSubset<T, RosterDeleteArgs<ExtArgs>>): Prisma.Prisma__RosterClient<runtime.Types.Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Roster.
   * @param {RosterUpdateArgs} args - Arguments to update one Roster.
   * @example
   * // Update one Roster
   * const roster = await prisma.roster.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends RosterUpdateArgs>(args: Prisma.SelectSubset<T, RosterUpdateArgs<ExtArgs>>): Prisma.Prisma__RosterClient<runtime.Types.Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Rosters.
   * @param {RosterDeleteManyArgs} args - Arguments to filter Rosters to delete.
   * @example
   * // Delete a few Rosters
   * const { count } = await prisma.roster.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends RosterDeleteManyArgs>(args?: Prisma.SelectSubset<T, RosterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Rosters.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RosterUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Rosters
   * const roster = await prisma.roster.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends RosterUpdateManyArgs>(args: Prisma.SelectSubset<T, RosterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Rosters and returns the data updated in the database.
   * @param {RosterUpdateManyAndReturnArgs} args - Arguments to update many Rosters.
   * @example
   * // Update many Rosters
   * const roster = await prisma.roster.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Rosters and only return the `id`
   * const rosterWithIdOnly = await prisma.roster.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends RosterUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, RosterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Roster.
   * @param {RosterUpsertArgs} args - Arguments to update or create a Roster.
   * @example
   * // Update or create a Roster
   * const roster = await prisma.roster.upsert({
   *   create: {
   *     // ... data to create a Roster
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Roster we want to update
   *   }
   * })
   */
  upsert<T extends RosterUpsertArgs>(args: Prisma.SelectSubset<T, RosterUpsertArgs<ExtArgs>>): Prisma.Prisma__RosterClient<runtime.Types.Result.GetResult<Prisma.$RosterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Rosters.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RosterCountArgs} args - Arguments to filter Rosters to count.
   * @example
   * // Count the number of Rosters
   * const count = await prisma.roster.count({
   *   where: {
   *     // ... the filter for the Rosters we want to count
   *   }
   * })
  **/
  count<T extends RosterCountArgs>(
    args?: Prisma.Subset<T, RosterCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], RosterCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Roster.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RosterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends RosterAggregateArgs>(args: Prisma.Subset<T, RosterAggregateArgs>): Prisma.PrismaPromise<GetRosterAggregateType<T>>

  /**
   * Group by Roster.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {RosterGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends RosterGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: RosterGroupByArgs['orderBy'] }
      : { orderBy?: RosterGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, RosterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRosterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Roster model
 */
readonly fields: RosterFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Roster.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__RosterClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  league<T extends Prisma.LeagueDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.LeagueDefaultArgs<ExtArgs>>): Prisma.Prisma__LeagueClient<runtime.Types.Result.GetResult<Prisma.$LeaguePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  member<T extends Prisma.LeagueMemberDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.LeagueMemberDefaultArgs<ExtArgs>>): Prisma.Prisma__LeagueMemberClient<runtime.Types.Result.GetResult<Prisma.$LeagueMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  players<T extends Prisma.Roster$playersArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Roster$playersArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$RosterPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Roster model
 */
export interface RosterFieldRefs {
  readonly id: Prisma.FieldRef<"Roster", 'String'>
  readonly createdAt: Prisma.FieldRef<"Roster", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"Roster", 'DateTime'>
  readonly leagueId: Prisma.FieldRef<"Roster", 'String'>
  readonly memberId: Prisma.FieldRef<"Roster", 'String'>
  readonly week: Prisma.FieldRef<"Roster", 'Int'>
  readonly season: Prisma.FieldRef<"Roster", 'Int'>
}
    

// Custom InputTypes
/**
 * Roster findUnique
 */
export type RosterFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Roster
   */
  select?: Prisma.RosterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Roster
   */
  omit?: Prisma.RosterOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterInclude<ExtArgs> | null
  /**
   * Filter, which Roster to fetch.
   */
  where: Prisma.RosterWhereUniqueInput
}

/**
 * Roster findUniqueOrThrow
 */
export type RosterFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Roster
   */
  select?: Prisma.RosterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Roster
   */
  omit?: Prisma.RosterOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterInclude<ExtArgs> | null
  /**
   * Filter, which Roster to fetch.
   */
  where: Prisma.RosterWhereUniqueInput
}

/**
 * Roster findFirst
 */
export type RosterFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Roster
   */
  select?: Prisma.RosterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Roster
   */
  omit?: Prisma.RosterOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterInclude<ExtArgs> | null
  /**
   * Filter, which Roster to fetch.
   */
  where?: Prisma.RosterWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Rosters to fetch.
   */
  orderBy?: Prisma.RosterOrderByWithRelationInput | Prisma.RosterOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Rosters.
   */
  cursor?: Prisma.RosterWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Rosters from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Rosters.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Rosters.
   */
  distinct?: Prisma.RosterScalarFieldEnum | Prisma.RosterScalarFieldEnum[]
}

/**
 * Roster findFirstOrThrow
 */
export type RosterFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Roster
   */
  select?: Prisma.RosterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Roster
   */
  omit?: Prisma.RosterOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterInclude<ExtArgs> | null
  /**
   * Filter, which Roster to fetch.
   */
  where?: Prisma.RosterWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Rosters to fetch.
   */
  orderBy?: Prisma.RosterOrderByWithRelationInput | Prisma.RosterOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Rosters.
   */
  cursor?: Prisma.RosterWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Rosters from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Rosters.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Rosters.
   */
  distinct?: Prisma.RosterScalarFieldEnum | Prisma.RosterScalarFieldEnum[]
}

/**
 * Roster findMany
 */
export type RosterFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Roster
   */
  select?: Prisma.RosterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Roster
   */
  omit?: Prisma.RosterOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterInclude<ExtArgs> | null
  /**
   * Filter, which Rosters to fetch.
   */
  where?: Prisma.RosterWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Rosters to fetch.
   */
  orderBy?: Prisma.RosterOrderByWithRelationInput | Prisma.RosterOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Rosters.
   */
  cursor?: Prisma.RosterWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Rosters from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Rosters.
   */
  skip?: number
  distinct?: Prisma.RosterScalarFieldEnum | Prisma.RosterScalarFieldEnum[]
}

/**
 * Roster create
 */
export type RosterCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Roster
   */
  select?: Prisma.RosterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Roster
   */
  omit?: Prisma.RosterOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterInclude<ExtArgs> | null
  /**
   * The data needed to create a Roster.
   */
  data: Prisma.XOR<Prisma.RosterCreateInput, Prisma.RosterUncheckedCreateInput>
}

/**
 * Roster createMany
 */
export type RosterCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Rosters.
   */
  data: Prisma.RosterCreateManyInput | Prisma.RosterCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Roster createManyAndReturn
 */
export type RosterCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Roster
   */
  select?: Prisma.RosterSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Roster
   */
  omit?: Prisma.RosterOmit<ExtArgs> | null
  /**
   * The data used to create many Rosters.
   */
  data: Prisma.RosterCreateManyInput | Prisma.RosterCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Roster update
 */
export type RosterUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Roster
   */
  select?: Prisma.RosterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Roster
   */
  omit?: Prisma.RosterOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterInclude<ExtArgs> | null
  /**
   * The data needed to update a Roster.
   */
  data: Prisma.XOR<Prisma.RosterUpdateInput, Prisma.RosterUncheckedUpdateInput>
  /**
   * Choose, which Roster to update.
   */
  where: Prisma.RosterWhereUniqueInput
}

/**
 * Roster updateMany
 */
export type RosterUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Rosters.
   */
  data: Prisma.XOR<Prisma.RosterUpdateManyMutationInput, Prisma.RosterUncheckedUpdateManyInput>
  /**
   * Filter which Rosters to update
   */
  where?: Prisma.RosterWhereInput
  /**
   * Limit how many Rosters to update.
   */
  limit?: number
}

/**
 * Roster updateManyAndReturn
 */
export type RosterUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Roster
   */
  select?: Prisma.RosterSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Roster
   */
  omit?: Prisma.RosterOmit<ExtArgs> | null
  /**
   * The data used to update Rosters.
   */
  data: Prisma.XOR<Prisma.RosterUpdateManyMutationInput, Prisma.RosterUncheckedUpdateManyInput>
  /**
   * Filter which Rosters to update
   */
  where?: Prisma.RosterWhereInput
  /**
   * Limit how many Rosters to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Roster upsert
 */
export type RosterUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Roster
   */
  select?: Prisma.RosterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Roster
   */
  omit?: Prisma.RosterOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterInclude<ExtArgs> | null
  /**
   * The filter to search for the Roster to update in case it exists.
   */
  where: Prisma.RosterWhereUniqueInput
  /**
   * In case the Roster found by the `where` argument doesn't exist, create a new Roster with this data.
   */
  create: Prisma.XOR<Prisma.RosterCreateInput, Prisma.RosterUncheckedCreateInput>
  /**
   * In case the Roster was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.RosterUpdateInput, Prisma.RosterUncheckedUpdateInput>
}

/**
 * Roster delete
 */
export type RosterDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Roster
   */
  select?: Prisma.RosterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Roster
   */
  omit?: Prisma.RosterOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterInclude<ExtArgs> | null
  /**
   * Filter which Roster to delete.
   */
  where: Prisma.RosterWhereUniqueInput
}

/**
 * Roster deleteMany
 */
export type RosterDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Rosters to delete
   */
  where?: Prisma.RosterWhereInput
  /**
   * Limit how many Rosters to delete.
   */
  limit?: number
}

/**
 * Roster.players
 */
export type Roster$playersArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the RosterPlayer
   */
  select?: Prisma.RosterPlayerSelect<ExtArgs> | null
  /**
   * Omit specific fields from the RosterPlayer
   */
  omit?: Prisma.RosterPlayerOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterPlayerInclude<ExtArgs> | null
  where?: Prisma.RosterPlayerWhereInput
  orderBy?: Prisma.RosterPlayerOrderByWithRelationInput | Prisma.RosterPlayerOrderByWithRelationInput[]
  cursor?: Prisma.RosterPlayerWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.RosterPlayerScalarFieldEnum | Prisma.RosterPlayerScalarFieldEnum[]
}

/**
 * Roster without action
 */
export type RosterDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Roster
   */
  select?: Prisma.RosterSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Roster
   */
  omit?: Prisma.RosterOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.RosterInclude<ExtArgs> | null
}
